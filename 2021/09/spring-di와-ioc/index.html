<!DOCTYPE html>
<html lang="en" >

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta property="og:title" content="Spring DI와 IoC" />
<meta property="og:description" content="Spring DI와 IoC의 개념에 대해 알아보자.
1. DI(Dependency Injection, 의존성 주입) DI(Dependency Injection) 은 스프링 프레임워크의 의존성 주입을 일컫는 말로, 특정 객체를 미리 생성 후 주입하는 것을 말한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://junu0516.github.io/2021/09/spring-di%EC%99%80-ioc/" />
<meta property="article:published_time" content="2021-09-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-09-20T00:00:00+00:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring DI와 IoC"/>
<meta name="twitter:description" content="Spring DI와 IoC의 개념에 대해 알아보자.
1. DI(Dependency Injection, 의존성 주입) DI(Dependency Injection) 은 스프링 프레임워크의 의존성 주입을 일컫는 말로, 특정 객체를 미리 생성 후 주입하는 것을 말한다."/>
<meta name="generator" content="Hugo 0.87.0" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring DI와 IoC",
  "url": "https://junu0516.github.io/2021/09/spring-di%EC%99%80-ioc/",
  "wordCount": "804",
  "datePublished": "2021-09-20T00:00:00+00:00",
  "dateModified": "2021-09-20T00:00:00+00:00",
  "author": {
    "@type": "Person",
    "name": "junu0516"
  },
  "keywords": "Spring, spring, java"
}
</script>



    <link rel="canonical" href="https://junu0516.github.io/2021/09/spring-di%EC%99%80-ioc/">

    <title>Spring DI와 IoC | Junu-Devlog</title>

    
    <!-- combined, minified CSS -->
    
    <link href="https://junu0516.github.io/css/style.876bbe11cfbbf3aedf883f4804dc283a275cd7f8b4ed0b540812126132c20313.css" rel="stylesheet" integrity="sha256-h2u&#43;Ec&#43;7867fiD9IBNwoOidc1/i07QtUCBISYTLCAxM=" crossorigin="anonymous">
    

    <!-- minified Font Awesome for SVG icons -->
    
    <script defer src="https://junu0516.github.io/js/fontawesome.min.a290d22177f491b8a83b0ee7eb739224c57ab052d8fab69d8f52aab860e42027.js" integrity="sha256-opDSIXf0kbioOw7n63OSJMV6sFLY&#43;radj1KquGDkICc=" crossorigin="anonymous"></script>

    <!-- RSS 2.0 feed -->
    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://junu0516.github.io/">Home</a>
        </nav>
      </div>
    </div>
    

    
    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title" dir="auto"><a href="https://junu0516.github.io/" rel="home">Junu-Devlog</a></h1>
        <p class="lead blog-description" dir="auto">배운 것을 기록하고 공유합니다.</p>
      </div>
    </header>
    
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title" dir="auto"><a href="https://junu0516.github.io/2021/09/spring-di%EC%99%80-ioc/">Spring DI와 IoC</a></h2>
    <p class="blog-post-meta">
<time datetime="2021-09-20T00:00:00Z">2021-09-20</time>
 in 
<span class="fas fa-folder" aria-hidden="true"></span>&nbsp;<a href="/categories/spring/" rel="category tag">Spring</a>


<span class="fas fa-tag" aria-hidden="true"></span>&nbsp;<a href="/tags/spring/" rel="tag">spring</a>, <a href="/tags/java/" rel="tag">java</a>

</p>
  </header>
  <p>Spring DI와 IoC의 개념에 대해 알아보자.</p>
<!-- raw HTML omitted -->
<p><img src="https://t1.daumcdn.net/cfile/tistory/2434D33454E702B835" alt="이러쿵저러쿵 :: 스프링(Spring) 프레임워크 기본 개념 강좌 (3) - IoC"></p>
<!-- raw HTML omitted -->
<h2 id="1-didependency-injection-의존성-주입">1. DI(Dependency Injection, 의존성 주입)</h2>
<p><strong><code>DI(Dependency Injection)</code></strong> 은 스프링 프레임워크의 의존성 주입을 일컫는 말로, 특정 객체를 미리 생성 후 주입하는 것을 말한다. 여기서 특정 클래스가 제 기능을 다하기 위해, 다른 클래스의 생성을 필요로하는 경우 클래스 간에  <strong><code>의존성</code></strong> 이 존재한다고 표현한다.</p>
<p>아래의 코드를 통해 의존성에 대해 살펴보도록 하자</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Car</span><span style="color:#f92672">{</span>
    Tire tire<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Car</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tire</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Tire<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>보통 의존 관계는 <strong><code>new</code></strong> 키워드를 선언하는 것과 밀접한 관련이 있다. 위의 코드에서 Car 클래스는 Tire 클래스를 필요로 하며, 따라서 Car 클래스는 Tire 클래스에 의존성을 가진다고 할 수 있다.</p>
<p>하지만 위와 같은 코드는 우선 Car 클래스와 Tire 클래스 간의 결합도가 높기 때문에, <strong>하나를 수정하면 다른 하나를 수정해야 하는 번거로움이 존재한다.</strong> 따라서, 결합도를 낮출수록(=의존성 혹은 종속성을 줄일수록) 코드의 재활용성 및 유연한 코드 작성이 가능해진다.</p>
<p>의존성의 주입은 아래처럼 생성자나 setter 메소드를 통해서도 가능하다.  new를 통해 직접 생성하지 않고, 외부에서 생성한 객체를 가져와 인스턴스에 할당하는 것이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Car</span><span style="color:#f92672">{</span>
    Tire tire<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Car</span><span style="color:#f92672">(</span>Tire tire<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tire</span> <span style="color:#f92672">=</span> tire<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setTire</span><span style="color:#f92672">(</span>Tire tire<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tire</span> <span style="color:#f92672">=</span> tire<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><!-- raw HTML omitted -->
<h2 id="2-iocinversion-of-conrol">2. IoC(Inversion of Conrol)</h2>
<p>스프링 프레임워크에서는 주입 대상이 되는 의존성 객체를 Bean이라고 한다. 처음 프로젝트가 실행될 때 Bean을 생성하여 Bean 컨테이너에서 관리하게 되고, 이후 필요시 컨테이너로부터 Bean을 주입받아 활용하는 것이다.</p>
<p>이러한 방식은 Bean 객체의 생성 및 소멸을 개발자가 아닌 프레임워크가 주도하게 함으로써, Singleton Pattern의 특징에서 알 수 있듯 빈번한 객체의 생성 및 소멸로 인한 자원 낭비를 줄이고 재사용성을 높인다는 이점이 있다.</p>
<p>이렇게 메소드나 객체의 호출을 개발자가 결정하지 않고, 프레임워크가 결정하는 것을 <strong><code>제어의 역전(Inversion of Control)</code></strong> 이라고 표현한다. 스프링에서의 Bean이 만들어지고 실행되는 과정은 아래와 같다.</p>
<ol>
<li>최초 객체가 생성된다.</li>
<li>의존성 객체가 주입된다.
<ul>
<li>필드 인스턴스나 setter 혹은 생성자 등을 통해 주입</li>
<li><code>@Autowired</code>  선언하여 프레임워크가 컨테이너에서, 선언된 객체 타입과 일치하는 Bean을 찾아 주입함</li>
</ul>
</li>
<li>의존성 객체 메소드가 호출된다.</li>
</ol>
<!-- raw HTML omitted -->
<p>여기서 의존성 객체를 주입할 때 스프링에서 권장하는 방식은 <strong>생성자방식</strong> 이다. 다양한 이유가 있겠지만, 공식문서에 의하면 주된 이유로 <strong>순환참조로 인한 에러를 사전에 방지</strong> 할 수 있다는 점을 언급하고 있다.</p>
<p>아래의 코드를 통해 살펴보도록 하자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Component</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span><span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Autowired</span>
    <span style="color:#66d9ef">private</span> Cat cag<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">call</span><span style="color:#f92672">(</span>Car cat<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Calling Cat&#34;</span><span style="color:#f92672">);</span>
        cat<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#a6e22e">@Component</span> 
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Autowired</span>
    <span style="color:#66d9ef">private</span> Dog dog<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">call</span><span style="color:#f92672">(</span>Dog dog<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Calling Dog&#34;</span><span style="color:#f92672">);</span>
        dog<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>위와 같이 필드 주입 방식을 통해 두 개의 Bean이 서로 의존하는 상황에서, 하나의 Bean이 내무의 call() 메소드를 호출할 경우에는  CallStack이 지속적으로 쌓이면서 <code>StackOverflowError</code>가 발생할 것이다. 쉽게 말해 Calling Cat -&gt; Calling Dog -&gt; Calling Cat -&gt; Calling Dog이 무한으로 반복되는 상황인 것이다.</p>
<p>문제는 이러한 예외는 컴파일 에러가 아닌 <strong>런타임 에러이기 때문에,</strong> 메소드가 실제로 호출되기 전까지는 순환참조된 부분을 찾아내기 힘들 수 있다. 만일, 생성자 주입 방식을 활용할 경우에는 이러한 순환참조 오류를 컴파일 시점에서 잡아낼 수 있기 때문에 생성자 주입 방식이 권장되는 것이다.</p>
<p>자바에서의 생성자 특성상 생성자 주입은 보통 <strong>최초 생성자 호출시 1회 호출되는 것이 보장</strong> 되기 때문에, 순환참조가 일어날 경우 <strong><code>BeanCurrentlyInCreationException</code></strong> 이 발생하여 사전에 문제를 방지할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Component</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span><span style="color:#f92672">{</span>
    
    <span style="color:#66d9ef">private</span> Cat cag<span style="color:#f92672">;</span>
    
    <span style="color:#a6e22e">@Autowired</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Dog</span><span style="color:#f92672">(</span>Car cat<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">cat</span> <span style="color:#f92672">=</span> cat<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">call</span><span style="color:#f92672">(</span>Car cat<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Calling Cat&#34;</span><span style="color:#f92672">);</span>
        cat<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#a6e22e">@Component</span> 
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">{</span>
    
    <span style="color:#66d9ef">private</span> Dog dog<span style="color:#f92672">;</span>
    
    <span style="color:#a6e22e">@Autowired</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">(</span>Dog dog<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">dog</span> <span style="color:#f92672">=</span> dog<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">call</span><span style="color:#f92672">(</span>Dog dog<span style="color:#f92672">){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Calling Dog&#34;</span><span style="color:#f92672">);</span>
        dog<span style="color:#f92672">.</span><span style="color:#a6e22e">call</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>위의 코드는 생성자 주입 방식을 적용한 것이다. 보통 단일 생성자만 존재하면 <code>@Autowired</code>를 사용하지 않아도 되지만, 2개 이상인 경우에는 반드시 어노테이션을 선언해야 한다.</p>
<!-- raw HTML omitted -->
<h2 id="3-스프링에서-bean-호출해보기">3. 스프링에서 Bean 호출해보기</h2>
<p>이번에는 간단한 예제를 통해 스프링의 Bean Container에서 IoC가 어떻게 이루어지는지 살펴보도록 하자. 여기서는 JDK1.5 이후 사용 가능한 Java Config 클래스를 통해 Bean Container를 구현하였다.</p>
<p>먼저, Bean으로 활용될 Car, Engine 두 개의 클래스를 아래와 같이 생성하였다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Car</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">private</span> Engine v8<span style="color:#f92672">;</span>
	
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Car</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Car 기본 생성자&#34;</span><span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setEngine</span><span style="color:#f92672">(</span>Engine e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">v8</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;엔진을 이용하여 달립니다.&#34;</span><span style="color:#f92672">);</span>
		v8<span style="color:#f92672">.</span><span style="color:#a6e22e">exec</span><span style="color:#f92672">();</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Engine</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Engine 기본 생성자&#34;</span><span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exec</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;엔진 동작&#34;</span><span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><!-- raw HTML omitted -->
<p>이후 Bean Container로 기능할 Java Config 클래스를 생성한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Configuration</span> <span style="color:#75715e">//해당 어노테이션을 읽고 해당 클래스가 config 파일임을 인지(스프링 설정 클래스)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApplicationConfig</span> <span style="color:#f92672">{</span>
	<span style="color:#75715e">/*
</span><span style="color:#75715e">	 * @Bean 어노테이션이 붙은 메소드(생성자)를 실행해서,
</span><span style="color:#75715e">	 * 리턴값으로 받은 객체들을 자동으로 싱글톤으로 관리해줌
</span><span style="color:#75715e">	 * pom.xml에서 일일히 등록하는 것보다 더욱 편리!!
</span><span style="color:#75715e">	 * 
</span><span style="color:#75715e">	 * */</span>
	
	<span style="color:#a6e22e">@Bean</span>
	<span style="color:#66d9ef">public</span> Car <span style="color:#a6e22e">car</span><span style="color:#f92672">(</span>Engine e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//클래스명과 실행파일에서의 getBean()의 매개변수를 서로 맞춰주도록 함
</span><span style="color:#75715e"></span>		Car c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Car<span style="color:#f92672">();</span>
		<span style="color:#75715e">//c.setEngine(e);
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> c<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
	
	<span style="color:#a6e22e">@Bean</span>
	<span style="color:#66d9ef">public</span> Engine <span style="color:#a6e22e">engine</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Engine<span style="color:#f92672">();</span>
	<span style="color:#f92672">}</span>	
<span style="color:#f92672">}</span>
</code></pre></div><p>위의 코드에서 <strong><code>@Configuration</code></strong> 어노테이션은, 간단히 말해 ApplicationConfig 클래스가 Bean Container로 기능할 것임을 나타내는 어노테이션이다. 해당 클래스 내에서  <strong><code>@Bean</code></strong> 어노테이션이 선언된 메소드들이 리턴하는 객체가 컨테이너가 가진 Bean이 된다.</p>
<p>이후에는 실행 메소드에서 직접 컨테이너를 생성해서 Bean을 주입해보도록 하자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ApplicationContextTest</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#75715e">//컨테이너 생성
</span><span style="color:#75715e"></span>        ApplicationContext ac <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AnnotationConfigApplicationContext<span style="color:#f92672">(</span>ApplicationConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
		
        <span style="color:#75715e">//컨테이너에서 Bean 호출
</span><span style="color:#75715e"></span>		Car car <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Car<span style="color:#f92672">)</span>ac<span style="color:#f92672">.</span><span style="color:#a6e22e">getBean</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;car&#34;</span><span style="color:#f92672">);</span>
		car<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
		
	<span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>여기서는 컨테이너의 구현체로 <strong><code>AnnotationConfigApplicationContext</code></strong> 클래스를 사용하였고, 매개변수로 앞서 생성한 <strong>ApplicationConfig</strong> 클래스를 넣어주었다.</p>
<p>이후 메인 메소드가 호출되면, AnnotationConfigApplicationContext는 생성자로 주입받은 config 클래스를 읽어 IoC를 적용하게 되며, config 클래스 내에 선언된 여러 Bean들이 싱글톤 방식으로 관리된다.</p>
<!-- raw HTML omitted -->
<hr>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85">위키피디아 의존성 주입</a></li>
<li><a href="https://www.baeldung.com/constructor-injection-in-spring">Constructor Dependency Injection in Spring</a></li>
<li><a href="https://velog.io/@gillog/Spring-DIDependency-Injection">[Spring] DI, IoC 정리</a></li>
</ul>


  

  
  <hr>
  <footer>

  
    <section>
    <h4>Share</h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fjunu0516.github.io%2f2021%2f09%2fspring-di%25EC%2599%2580-ioc%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjunu0516.github.io%2f2021%2f09%2fspring-di%25EC%2599%2580-ioc%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjunu0516.github.io%2f2021%2f09%2fspring-di%25EC%2599%2580-ioc%2f&amp;text=Spring%20DI%ec%99%80%20IoC" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  
  <section class="sidebar-module sidebar-module-inset">
    <h4>About</h4>
    <p dir="auto">About me</p>
  </section>
  

  
        <section class="sidebar-module">
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">


<li><a href="/2021/09/tcp/ip-4%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%9D%B4%ED%95%B4/">TCP/IP 4계층의 이해</a></li>

<li><a href="/2021/09/operating-system-concepts-chapter-1-%EC%9A%94%EC%95%BD/">Operating System Concepts - Chapter 1 요약</a></li>

<li><a href="/2021/09/spring-di%EC%99%80-ioc/">Spring DI와 IoC</a></li>

    </ol>
  </section>

  

  
  <section class="sidebar-module">
    <h4>Links</h4>
    <ol class="list-unstyled">
      
      <li><a href="https://example.com">Link 1</a></li>
      
      <li><a href="https://example.org">Link 2</a></li>
      
    </ol>
  </section>
  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p dir="auto">
      
      Hugo Theme Bootstrap v4 Blog(<a href="https://github.com/alanorth/hugo-theme-bootstrap4-blog">https://github.com/alanorth/hugo-theme-bootstrap4-blog</a>)
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
